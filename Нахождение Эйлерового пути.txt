#include <iostream>
using namespace std;
int proverka(int A[9][9]) //Проверка графа на эйлеровость
{
	int i, j, k;
	int deg[9];      //степень вершин
	int S1 = 0, S2 = 0;  //полустепень входа и выхода
	for (i = 0; i<9; i++)
	{
		for (j = 0; j<9; j++)
		{
			S1 += A[i][j];
			S2 += A[j][i];
		}
		deg[i] = S1 - S2;
	}
	j = 0;
	int a = 10;          //результат проверки
	for (i = 0; i<9; i++)
	{
		if (deg[i] % 2 == 1)
		{
			j++;
			if (i<a) a = i;
		}
	}
	if (j == 0)    //все вершины чётные
	{
		a = 0;
		return a;
	}
	else if (j == 2) return a;   //2 нечётные вершины
	else
		return 10;
}
void PoiskPuti(int S, int e, int A[9][9])  //Нахождение пути. В функцию передаем число рёбер (S), вершину, с которой начинаем путь (е) и сам граф
{
	int i, j, k;
	int Stek[S + 1]; //Массив, в который запиываем путь
	for (i = 0; i<S + 1; i++)
	{
		Stek[i] = 0;
	}

	int st;   //счётчик заполнения стека
	Stek[0] = e + 1;
	st = 1;
	i = e;     // строка, соответствующая вершине начала
	while (Stek[S] == 0)
	{


		for (j = 0; j < 9; j++)
		{
			if (A[i][j] == 1)   //Если в матрице есть единица, т.е есть ребро из i в j.
			{
				if (st == S)
				{        //если находимся в последнем ребре, записать и вершину выхода и вершину входа
					Stek[st - 1] = i + 1;
					Stek[st] = j + 1;
					break;
				}

				for (k = 0; k<9; k++)     //  Проверяем существование пути дальше
				{
					if (A[j][k] != 0)
					{
						Stek[st] = j + 1;
						++st;
						A[i][j] = 0;
						i = j;
						j = 0;
						break;
					}
				}
			}
		}
	}
	for (i = 0; i<S; i++)
	{
		cout << Stek[i] << " -> ";
	}
	cout << Stek[S];
}

int main()
{
	setlocale(LC_ALL, "RUS");
	int S = 0;
	int i, j, k;
	int G[9][9] = {
		{ 0, 1, 1, 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 1, 1, 0, 0, 0, 0 },
		{ 0, 0, 0, 1, 0, 1, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 1, 0, 0, 0 },
		{ 0, 0, 0, 0, 0, 0, 1, 0, 1 },
		{ 0, 0, 0, 0, 0, 0, 0, 1, 1 },
		{ 1, 1, 0, 0, 0, 0, 0, 0, 0 },
		{ 1, 0, 1, 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 0, 0, 1, 1, 0 }
	};
	for (i = 0; i<9; i++)
	{
		for (j = 0; j<9; j++)
		{
			S += G[i][j];
		}
	}
	int e = proverka(G);
	if (e == 10)
	{
		cout << "Граф не эйлеров";
		return 0;
	}
	else
	{
		cout << "Граф имеет эйлеров путь\n";
		PoiskPuti(S, e, G);

	}
	return 0;
}
